{
	// Place your atcoder ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cpp": {
        "prefix": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#define arep(i,x,n) for(int i=int(x);i<(int)(n);i++)",
            "#define rep(i,n) for(ll i = 0;i < n;++i)",
            "#define rrep(i,n) for(int i=int(n-1);i>=0;i--)",
            "#define fs first",
            "#define sc second",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define coy cout<<\"Yes\"<<endl",
            "#define con cout<<\"No\"<<endl",
            "#define pi 3.141592653589793",
            "#define eps 0.00000001",
            "#define INF 1e9+7",
            "#define LINF (ll)1e18+10  ",
            "using ll = long long;",
            "",
            "using P = pair<ll, ll>;",
            "using lP = pair<ll, ll>;",
            "using fP = pair<double, double>;",
            "using PPI = pair<P, int>;",
            "using PIP = pair<int, P>;",
            "using Ps = pair<int, string>;",
            "",
            "using vi = vector<int>;",
            "using vl = vector<ll>;",
            "using vc = vector<char>;",
            "using vd = vector<double>;",
            "using vs = vector<string>;",
            "using vp = vector<P>;",
            "using vb = vector<bool>;",
            "using vvi = vector<vector<int>>;",
            "using vvl = vector<vector<ll>>;",
            "using vvd = vector<vector<double>>;",
            "using vvc = vector<vector<char>>;",
            "using vvp = vector<vector<P>>;",
            "using vvb = vector<vector<bool>>;",
            "template <typename T>",
            "bool chmax(T& a, const T b) { if (a < b) { a = b; return true; } return false; }",
            "template <typename T>",
            "bool chmin(T& a, const T b) { if (a > b) { a = b; return true; } return false; }",
            "",
            "//const ll mod=998244353;",
            "const ll mod = 1e9 + 7;",
            "const ll MAX = 100;",
            "template <typename T>",
            "T abs(T a) { if (a < 0)return -a; else return a; }//2020/09/30 stdlib has abs(long) abs(long long) error",
            "",
            "//////////////////////////////////////",
            "",
            "int main(){",
            "    $1",
            "    return 0;",
            "}",
        ],
        "description": ""
    },
    "union find": {
        "prefix": "UnionFind",
        "body": [
            "class UnionFind {",
            "public:",
            "    vector <ll> par; // 各元の親を表す配列",
            "    vector <ll> siz; // 素集合のサイズを表す配列(1 で初期化)",
            " ",
            "    // Constructor",
            "    UnionFind(ll sz_): par(sz_), siz(sz_, 1LL) {",
            "        for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身",
            "    }",
            "    void init(ll sz_=1) {",
            "        par.resize(sz_);",
            "        siz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった",
            "        for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身",
            "    }",
            " ",
            "    // Member Function",
            "    // Find",
            "    ll root(ll x) { // 根の検索",
            "        while (par[x] != x) {",
            "            x = par[x] = par[par[x]]; // x の親の親を x の親とする",
            "        }",
            "        return x;",
            "    }",
            " ",
            "    // Union(Unite, Merge)",
            "    bool merge(ll x, ll y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if (x == y) return false;",
            "        // merge technique（データ構造をマージするテク．小を大にくっつける）",
            "        if (siz[x] < siz[y]) swap(x, y);",
            "        siz[x] += siz[y];",
            "        par[y] = x;",
            "        return true;",
            "    }",
            " ",
            "    bool issame(ll x, ll y) { // 連結判定",
            "        return root(x) == root(y);",
            "    }",
            " ",
            "    ll size(ll x) { // 素集合のサイズ",
            "        return siz[root(x)];",
            "    }",
            "};",
        ],
        "description": ""
    },

    "modpow": {
        "prefix": "modpow",
        "body": [
            "template <typename T>",
            "T modpow(T a, int b) {",
            "    T r = 1;",
            "    while (b > 0) {",
            "        if (b % 2 == 1)(r *= a);",
            "        (a *= a);",
            "        b /= 2;",
            "    }",
            "    return r;",
            "}",
        ],
        "description": ""
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template <typename T>",
            "vector<T> divisor(T n){",
            "    vector<T> ret;",
            "    for(T i=1:I*I<=n;i++){",
            "        if(n%i==0){",
            "            ret.push_back(i);",
            "            if(i*i!=n)ret.push_back(n/i);",
            "        }",
            "    }",
            "    sort(ret.begin(),ret.end());",
            "    return ret;",
            "}",
        ],
        "description": "約数列挙"
    },
    "gcd": {
        "prefix": "gcd",
        "body": [
            "template<typename T>",
            "T gcd(T a, T b){",
            "    if(b==0) return a;",
            "    else return gcd(b, a%b);",
            "}",
        ],
        "description": ""
    },
    "prime_factor": {
        "prefix": "prime_factor",
        "body": [
            "template<typename T>",
            "map<T,int> prime_factor(T n){",
            "    map<T,int> ret;",
            "    for(T i=2:i*i<=n;i++){",
            "        while(n%i==0){",
            "            ret[i]++;",
            "            n/=i;",
            "        }",
            "    }",
            "    if(n!=1)ret[n]=1;",
            "    return ret;",
            "}",
        ],
        "description": "素因数分解"
    },
    "eratos": {
        "prefix": "eratos",
        "body": [
            "vector<long long> Eratos(ll MAXP){",
            "  vector<long long> res;",
            "  vector<int> mem(MAXP,0);",
            "  for(int i=2;i<MAXP;i++){",
            "    if(mem[i]){continue;}",
            "    res.push_back(i);",
            "    for(int j=i;j<MAXP;j+=i){mem[j]=1;}",
            "  }",
            "  return res;",
            "}",
        ],
        "description": "素数列挙"
    },


}